
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>DOM二级和三级.md | HappyLiuJian</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Liujian">
    
    <meta name="description" content="DOM2 和 DOM3 级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。为此，DOM2和DOM3级分为许多模块（模块之间具有某种关联),分别描述了DOM的某个非常具体的子集。检测是否具有特性var supportsDOM2Core = document.implementat">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="HappyLiuJian" title="HappyLiuJian"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="HappyLiuJian">HappyLiuJian</a></h1>
				<h2 class="blog-motto">HappyLiuJian&#39;s Home</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/09/24/DOM二级和三级-md/" title="DOM二级和三级.md" itemprop="url">DOM二级和三级.md</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://yoursite.com" title="Liujian">Liujian</a>
    </p>
  <p class="article-time">
    <time datetime="2015-09-24T13:40:24.000Z" itemprop="datePublished">2015-09-24</time>
    更新日期:<time datetime="2015-09-24T13:42:08.108Z" itemprop="dateModified">2015-09-24</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目錄</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DOM2_和_DOM3_级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。为此，DOM2和DOM3级分为许多模块（模块之间具有某种关联),分别描述了DOM的某个非常具体的子集。"><span class="toc-number">1.</span> <span class="toc-text">DOM2 和 DOM3 级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。为此，DOM2和DOM3级分为许多模块（模块之间具有某种关联),分别描述了DOM的某个非常具体的子集。</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#检测是否具有特性"><span class="toc-number">1.1.</span> <span class="toc-text">检测是否具有特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM变化"><span class="toc-number">1.2.</span> <span class="toc-text">DOM变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#针对命名空间问题，Node出现以下的变化"><span class="toc-number">1.2.1.</span> <span class="toc-text">针对命名空间问题，Node出现以下的变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#样式"><span class="toc-number">1.3.</span> <span class="toc-text">样式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#操作样式表"><span class="toc-number">1.3.1.</span> <span class="toc-text">操作样式表</span></a></li></ol></li></ol></li></ol>
		</div>
		
		<h1 id="DOM2_和_DOM3_级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。为此，DOM2和DOM3级分为许多模块（模块之间具有某种关联),分别描述了DOM的某个非常具体的子集。">DOM2 和 DOM3 级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。为此，DOM2和DOM3级分为许多模块（模块之间具有某种关联),分别描述了DOM的某个非常具体的子集。</h1><h2 id="检测是否具有特性">检测是否具有特性</h2><pre><code><span class="reserved">var</span> supportsDOM2Core = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"Core"</span>, <span class="string">"2.0"</span>);
<span class="reserved">var</span> supportsDOM3Core = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"Core"</span>, <span class="string">"3.0"</span>);
<span class="reserved">var</span> supportsDOM2HTML = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"HTML"</span>, <span class="string">"2.0"</span>);
<span class="reserved">var</span> supportsDOM2Views = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"Views"</span>, <span class="string">"2.0"</span>);
<span class="reserved">var</span> supportsDOM2XML = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"XML"</span>, <span class="string">"2.0"</span>);
</code></pre><h2 id="DOM变化">DOM变化</h2><h3 id="针对命名空间问题，Node出现以下的变化">针对命名空间问题，Node出现以下的变化</h3><ul>
<li><p>属性变化：<br>localName: 不带命名空间前缀的节点名称<br>namespaceURl: 命名空间 URI 或者（在未指定的情况下是） null<br>prefix: 命名空间前缀或者（在未指定的情况下是） null<br>当节点使用了命名空间前缀时，其 nodeName 等于 prefix+”:”+ localName</p>
</li>
<li><p>Document变化：<br>针对命名空间问题，Document出现以下的变化<br>createElementNS(namespaceURI, tagName)：使用给定的 tagName 创建一个属于命名空间namespaceURI 的新元素<br>createAttributeNS(namespaceURI, attributeName)：使用给定的 attributeName 创建一个属于命名空间 namespaceURI 的新特性<br>getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间 namespaceURI的 tagName 元素的 NodeList</p>
</li>
<li><p>Element变化<br>getAttributeNS(namespaceURI,localName)：取得属于命名空间 namespaceURI 且名为localName的特性<br>getAttributeNodeNS(namespaceURI,localName):取得属于命名空间namespaceURI且名为localName的特性节点<br>getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间 namespaceURI的tagName元素的 NodeList<br>hasAttributeNS(namespaceURI,localName)：确定当前元素是否有一个名为 localName的特性，而且该特性的命名空间是 namespaceURI<br>removeAttriubteNS(namespaceURI,localName)：删除属于命名空间 namespaceURI 且名为 localName 的特性<br>setAttributeNS(namespaceURI,qualifiedName,value)：设置属于命名空间 namespaceURI 且名为 qualifiedName 的特性的值为 value<br>setAttributeNodeNS(attNode)：设置属于命名空间 namespaceURI 的特性节点</p>
</li>
<li><p>NameNodeMap变化<br>由于特性是通过 NamedNodeMap 表示的，因此这些方法多数情况下只针对特性使用<br>getNamedItemNS(namespaceURI,localName)：取得属于命名空间 namespaceURI 且名为localName 的项<br>removeNamedItemNS(namespaceURI,localName)：移除属于命名空间 namespaceURI 且名为 localName 的项<br>setNamedItemNS(node)：添加 node，这个节点已经事先指定了命名空间信息</p>
</li>
</ul>
<h2 id="样式">样式</h2><p>在style特性中指定的任何CSS属性都将表现为这个style对象的相应属性。对于使用短划线(分隔不同的词汇,例如 background-image)的CSS属性名，必须将其转换成驼峰大小写形式，才能通过 JavaScript 来访问</p>
<p>如：background-image     —      style.backgroundImage<br>float不能直接转换，因为它是js的保留字，所以使用cssFloat/styleFloat(IE)来进行访问</p>
<p>通过 cssText 属性可以访问 style 特性中的 CSS 代码。在读取模式下，cssText 返回浏览器对 style特性中 CSS 代码的内部表示。在写入模式下，赋给 cssText 的值会重写整个 style 特性的值</p>
<pre><code>myDiv.style.cssText = "width: 25px<span class="comment">; height: 100px; background-color: green";</span>
alert(myDiv.style.cssText)<span class="comment">;</span>
</code></pre><p>cssText可以方便的一次性重写所有的style属性值</p>
<p>设计 length 属性的目的，就是将其与 item()方法配套使用，以便迭代在元素中定义的 CSS 属性。无论是使用方括号语法还是使用 item()方法，都可以取得 CSS 属性名（”background-color”，不是”backgroundColor”）</p>
<pre><code><span class="keyword">var</span> <span class="keyword">prop</span>, value, i, len;
<span class="keyword">for</span> (i=0, len=myDiv.style.length; i &lt; len; i++){
    <span class="keyword">prop</span> = myDiv.style[i]; <span class="comment">//或者 myDiv.style.item(i)</span>
    value = myDiv.style.getPropertyValue(<span class="keyword">prop</span>);
    alert(<span class="keyword">prop</span> + <span class="string">" : "</span> + value);
}
</code></pre><p>获取计算后的样式，在IE中使用具有style属性的元素也具有currentStyle属性，具有同样的效果</p>
<pre><code><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Computed Styles Example<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">"text/css"</span>&gt;</span><span class="css">
    <span class="id">#myDiv</span> <span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> blue</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">200px</span></span></span>;
    }</span>
    </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"myDiv"</span> <span class="attribute">style</span>=<span class="value">"background-color: red; border: 1px solid black"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>

var myDiv = document.getElementById("myDiv");
var computedStyle = document.defaultView.getComputedStyle(myDiv, null);
alert(computedStyle.backgroundColor); // "red"
alert(computedStyle.width); // "100px"
alert(computedStyle.height); // "200px"
alert(computedStyle.border); // 在某些浏览器中是"1px solid black"
</code></pre><h3 id="操作样式表">操作样式表</h3><p>CSSStyleSheet 类型表示的是样式表,包括通过<link>元素包含的样式表和在<style>元素中定义的样式表<br>每一个元素都有自己的这个属性。应用于文档的所有样式表是通过<br>        document.styleSheets<br>集合来表示的。通过这个集合的length属性可以获知文档中样式表的数量</p>
<p>这个属性主要是用来描述css样式表的特性，而style属性描述的则是css的内容</p>
<p>CSSRule 对象表示样式表中的每一条规则。实际上， CSSRule 是一个供其他多种类型继承的基类<br>型，其中最常见的就是 CSSStyleRule 类型，表示样式信息（其他规则还有@import、 @font-face、<br>@page 和@charset，但这些规则很少有必要通过脚本来访问）</p>
<p>CSSRule 对象表示样式表中的每一条规则。实际上， CSSRule 是一个供其他多种类型继承的基类<br>型，其中最常见的就是 CSSStyleRule 类型，表示样式信息（其他规则还有@import、 @font-face、<br>@page 和@charset，但这些规则很少有必要通过脚本来访问）</p>
<p>要向现有样式表中添加新规则，需要使用 insertRule()方法。这个方法接受两个参数：规则文本和表示在哪里插入规则的索引</p>
<pre><code><span class="tag">sheet</span><span class="class">.insertRule</span>(<span class="string">"body { background-color: silver }"</span>, <span class="number">0</span>); <span class="comment">//DOM 方法</span>
</code></pre><p>从样式表中删除规则的方法是 deleteRule()，这个方法接受一个参数：要删除的规则的位置</p>
<pre><code><span class="tag">sheet</span><span class="class">.deleteRule</span>(0); 
</code></pre><h2 id="元素大小">元素大小</h2><p>偏移量</p>
<p>首先要介绍的属性涉及偏移量（offset dimension），包括元素在屏幕上占用的所有可见的空间。元素<br>的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）。<br>通过offestHeight、offestWidth、offestLeft、offestTop可以分别访问这几种信息</p>
<p>获取实际左偏移的函数</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span><span class="params">(element)</span></span>{
    <span class="keyword">var</span> actualLeft = element.offsetLeft;
    <span class="keyword">var</span> current = element.offsetParent;
    <span class="keyword">while</span> (current !== <span class="literal">null</span>){
        actualLeft += current.offsetLeft;
        current = current.offsetParent;
    }
    <span class="keyword">return</span> actualLeft;
}
</code></pre><p>客户区大小</p>
<p>元素的客户区大小（client dimension），指的是元素内容及其内边距所占据的空间大小。有关客户区<br>大小的属性有两个： clientWidth 和 clientHeight。其中， clientWidth 属性是元素内容区宽度加<br>上左右内边距宽度； clientHeight 属性是元素内容区高度加上上下内边距高度。</p>
<p>滚动大小</p>
<p>最后要介绍的是滚动大小（scroll dimension），指的是包含滚动内容的元素的大小。有些元素（例如</p>
<p><html>元素），即使没有执行任何代码也能自动地添加滚动条；但另外一些元素，则需要通过 CSS 的<br>overflow 属性进行设置才能滚动<br>scrollHeight：在没有滚动条的情况下，元素内容的总高度。<br>scrollWidth：在没有滚动条的情况下，元素内容的总宽度。<br>scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。<br>scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置</p>
<p>确定元素大小</p>
<p>每个元素都提供了一个 getBoundingClientRect()方<br>法。这个方法返回会一个矩形对象，包含 4 个属性： left、 top、 right 和 bottom。。浏览器的实现稍有不同。 IE8 及更早版本认为文档的左上角坐<br>标是(2, 2)，而其他浏览器包括 IE9 则将传统的(0,0)作为起点坐标。因此，就需要在一开始检查一下位于<br>(0,0)处的元素的位置，在 IE8 及更早版本中，会返回(2,2)，而在其他浏览器中会返回(0,0)。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">getBoundingClientRect</span>(<span class="params">element</span>)</span>{
    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.offset != <span class="string">"number"</span>){
        <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;
        <span class="keyword">var</span> temp = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);
        temp.style.cssText = <span class="string">"position:absolute;left:0;top:0;"</span>;
        <span class="built_in">document</span>.body.appendChild(temp);
        <span class="built_in">arguments</span>.callee.offset = -temp.getBoundingClientRect().top - scrollTop;
        <span class="built_in">document</span>.body.removeChild(temp);
        temp = <span class="literal">null</span>;
    }
    <span class="keyword">var</span> rect = element.getBoundingClientRect();
    <span class="keyword">var</span> offset = <span class="built_in">arguments</span>.callee.offset;
    <span class="keyword">return</span> {
        left: rect.left + offset,
        right: rect.right + offset,
        top: rect.top + offset,
        bottom: rect.bottom + offset
    };
}
</code></pre><p>最终的 offset 会被设置为新元素上坐标的负值，实际上就是在 IE 中设置为2，在<br>Firefox 和 Opera 中设置为0。</p>
<p>对于不支持getBoundingClientRect()的浏览器，可以采用以下函数实现位置</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">getBoundingClientRect</span>(<span class="params">element</span>)</span>{
    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;
    <span class="keyword">var</span> scrollLeft = <span class="built_in">document</span>.documentElement.scrollLeft;
    <span class="keyword">if</span> (element.getBoundingClientRect){
        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.offset != <span class="string">"number"</span>){
        <span class="keyword">var</span> temp = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);
        temp.style.cssText = <span class="string">"position:absolute;left:0;top:0;"</span>;
        <span class="built_in">document</span>.body.appendChild(temp);
        <span class="built_in">arguments</span>.callee.offset = -temp.getBoundingClientRect().top - scrollTop;
        <span class="built_in">document</span>.body.removeChild(temp);
        temp = <span class="literal">null</span>;
        }
        <span class="keyword">var</span> rect = element.getBoundingClientRect();
        <span class="keyword">var</span> offset = <span class="built_in">arguments</span>.callee.offset;
        <span class="keyword">return</span> {
        left: rect.left + offset,
        right: rect.right + offset,
        top: rect.top + offset,
        bottom: rect.bottom + offset
        };
    } <span class="keyword">else</span> {
        <span class="keyword">var</span> actualLeft = getElementLeft(element);
        <span class="keyword">var</span> actualTop = getElementTop(element);
        <span class="keyword">return</span> {
        left: actualLeft - scrollLeft,
        right: actualLeft + element.offsetWidth - scrollLeft,
        top: actualTop - scrollTop,
        bottom: actualTop + element.offsetHeight - scrollTop
    }
    }
}
</code></pre><p>遍历</p>
<p>“ DOM2 级遍历和范围”模块定义了两个用于辅助完成顺序遍历 DOM 结构的类型： NodeIterator<br>和 TreeWalker。这两个类型能够基于给定的起点对 DOM 结构执行深度优先（depth-first）的遍历操作</p>
<p>NodeIterator类型</p>
<p>可以使用 document.createNodeIterator()方<br>法创建它的新实例。这个方法接受下列 4 个参数。<br> root：想要作为搜索起点的树中的节点。<br> whatToShow：表示要访问哪些节点的数字代码。<br> filter：是一个 NodeFilter 对象，或者一个表示应该接受还是拒绝某种特定节点的函数。<br> entityReferenceExpansion：布尔值，表示是否要扩展实体引用。这个参数在 HTML 页面<br>中没有用，因为其中的实体引用不能扩展</p>
<pre><code><span class="keyword">var</span> filter = {
    acceptNode: function(node){
    <span class="keyword">return</span> node.tagName.toLowerCase() == <span class="string">"p"</span> ?
    <span class="type">NodeFilter</span>.<span class="type">FILTER_ACCEPT</span> :
    <span class="type">NodeFilter</span>.<span class="type">FILTER_SKIP</span>;
    }
};
<span class="keyword">var</span> <span class="keyword">iterator</span> = document.createNodeIterator(root, <span class="type">NodeFilter</span>.<span class="type">SHOW_ELEMENT</span>,
filter, <span class="literal">false</span>);
</code></pre><p>NodeIterator 类型的两个主要方法是 nextNode()和 previousNode()</p>
<pre><code>&lt;<span class="keyword">div</span> id=<span class="string">"div1"</span>&gt;
    &lt;p&gt;&lt;b&gt;<span class="type">Hello</span>&lt;/b&gt; world!&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;<span class="type">List</span> item <span class="number">1</span>&lt;/li&gt;
        &lt;li&gt;<span class="type">List</span> item <span class="number">2</span>&lt;/li&gt;
        &lt;li&gt;<span class="type">List</span> item <span class="number">3</span>&lt;/li&gt;
    &lt;/ul&gt;
&lt;/<span class="keyword">div</span>&gt;

<span class="keyword">var</span> <span class="keyword">div</span> = document.getElementById(<span class="string">"div1"</span>);    //输出所有<span class="keyword">div</span>之下的元素
<span class="keyword">var</span> <span class="keyword">iterator</span> = document.createNodeIterator(<span class="keyword">div</span>, <span class="type">NodeFilter</span>.<span class="type">SHOW_ELEMENT</span>,
null, <span class="literal">false</span>);
<span class="keyword">var</span> node = <span class="keyword">iterator</span>.nextNode();
<span class="keyword">while</span> (node !== null) {
    alert(node.tagName); //输出标签名
    node = <span class="keyword">iterator</span>.nextNode();
}
</code></pre><p>TreeWalker类型</p>
<p>TreeWalker 是 NodeIterator 的一个更高级的版本。除了包括 nextNode()和 previousNode()<br>在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历 DOM 结构的方法。<br>parentNode()：遍历到当前节点的父节点；<br>firstChild()：遍历到当前节点的第一个子节点；<br>lastChild()：遍历到当前节点的最后一个子节点；<br>nextSibling()：遍历到当前节点的下一个同辈节点；<br>previousSibling()：遍历到当前节点的上一个同辈节点。</p>
<p>创建 TreeWalker 对象要使用 document.createTreeWalker()方法，这个方法接受的 4 个参数<br>与 document.createNodeIterator()方法相同</p>
<pre><code><span class="keyword">var</span> <span class="keyword">div</span> = document.getElementById(<span class="string">"div1"</span>);
<span class="keyword">var</span> filter = function(node){
    <span class="keyword">return</span> node.tagName.toLowerCase() == <span class="string">"li"</span>?
    <span class="type">NodeFilter</span>.<span class="type">FILTER_ACCEPT</span> :
    <span class="type">NodeFilter</span>.<span class="type">FILTER_SKIP</span>;
};
<span class="keyword">var</span> walker= document.createTreeWalker(<span class="keyword">div</span>, <span class="type">NodeFilter</span>.<span class="type">SHOW_ELEMENT</span>,
filter, <span class="literal">false</span>);
<span class="keyword">var</span> node = <span class="keyword">iterator</span>.nextNode();
<span class="keyword">while</span> (node !== null) {
    alert(node.tagName); //输出标签名
    node = <span class="keyword">iterator</span>.nextNode();
}
</code></pre><p>在这里， filter 可以返回的值有所不同。除了 NodeFilter.FILTER_ACCEPT 和 NodeFilter.<br>FILTER_SKIP 之外，还可以使用 NodeFilter.FILTER_REJECT。</p>
<p>在使<br>用 TreeWalker 对象时， NodeFilter.FILTER_SKIP 会跳过相应节点继续前进到子树中的下一个节点，<br>而 NodeFilter.FILTER_REJECT 则会跳过相应节点及该节点的整个子树</p>
<pre><code><span class="variable"><span class="keyword">var</span> div</span> = document.getElementById(<span class="string">"div1"</span>);
<span class="variable"><span class="keyword">var</span> walker</span> = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, <span class="literal">null</span>, <span class="literal">false</span>);
walker.firstChild(); <span class="comment">//转到&lt;p&gt;</span>
walker.nextSibling(); <span class="comment">//转到&lt;ul&gt;</span>
<span class="variable"><span class="keyword">var</span> node</span> = walker.firstChild(); <span class="comment">//转到第一个&lt;li&gt;</span>
<span class="keyword">while</span> (node !== <span class="literal">null</span>) {
    alert(node.tagName);
    node = walker.nextSibling();
}
</code></pre><p>如上所示：利用TreeWalker的各个方向都可以跳转的特性，可以方便的不利用filter也可以访问所有li元素</p>
<p>范围</p>
<p>如果浏览器支持范围，那么就可以使用 createRange()来创建 DOM 范围，如下所示：<br>var range = document.createRange();</p>
<p>每个范围由一个 Range 类型的实例表示，这个实例拥有很多属性和方法。下列属性提供了当前范<br>围在文档中的位置信息。<br> startContainer：包含范围起点的节点（即选区中第一个节点的父节点）。<br> startOffset：范围在 startContainer 中起点的偏移量。如果 startContainer 是文本节<br>点、注释节点或 CDATA 节点，那么 startOffset 就是范围起点之前跳过的字符数量。否则，<br>startOffset 就是范围中第一个子节点的索引。<br> endContainer：包含范围终点的节点（即选区中最后一个节点的父节点）。<br> endOffset：范围在 endContainer 中终点的偏移量 （与 startOffset 遵循相同的取值规则）。<br> commonAncestorContainer： startContainer 和 endContainer 共同的祖先节点在文档树<br>中位置最深的那个。</p>
<p>使用范围做选择</p>
<p>要使用范围来选择文档中的一部分，最简的方式就是使用 selectNode()或 selectNodeContents()。<br>这两个方法都接受一个参数，即一个 DOM 节点，然后使用该节点中的信息来填充范围</p>
<pre><code><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span>
        <span class="tag">&lt;<span class="title">p</span> <span class="attribute">id</span>=<span class="value">"p1"</span>&gt;</span><span class="tag">&lt;<span class="title">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="title">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
//我们可以使用下列代码来创建范围：
var range1 = document.createRange();
range2 = document.createRange();
p1 = document.getElementById("p1");
range1.selectNode(p1);
range2.selectNodeContents(p1);
</code></pre><p>要创建复杂的范围就得使用 setStart()和 setEnd()方法。这两个方法都接受两个参数：一个参<br>照节点和一个偏移量值。对 setStart()来说，参照节点会变成 startContainer，而偏移量值会变成<br>startOffset。对于 setEnd()来说，参照节点会变成 endContainer，而偏移量值会变成 endOffset</p>
<pre><code>var p1 = document.getElementById("p1")<span class="comment">;</span>
helloNode = p1.firstChild.firstChild<span class="comment">;</span>
worldNode = p1.lastChild<span class="comment">;</span>
var range = document.createRange()<span class="comment">;</span>
range.setStart(helloNode, 2)<span class="comment">;</span>
range.setEnd(worldNode, 3)<span class="comment">;</span>
</code></pre><p>用来获取p元素的文本中的”Hello”中的”llo”到”world!”中的o的所有内容</p>
<p>操作DOM范围</p>
<p>deleteContents()方法：这个方法能够从文档中删除范<br>围所包含的内容</p>
<p>与 deleteContents()方法相似， extractContents()也会从文档中移除范围选区。但这两个方<br>法的区别在于， extractContents()会返回范围的文档片段。利用这个返回的值，可以将范围的内容<br>插入到文档中的其他地方</p>
<p>还一种做法，即使用 cloneContents()创建范围对象的一个副本，然后在文档的其他地方插入该<br>副本</p>
<p>使用 insertNode()<br>方法可以向范围选区的开始处插入一个节点</p>
<p>使用 collapse()方法来折叠范围，这个方法接受一个参数，一个布尔值，表示要折叠到范围的哪<br>一端。参数 true 表示折叠到范围的起点，参数 false 表示折叠到范围的终点<br>这个方法主要用来将鼠标光标放到选中行的首或者尾</p>
<p>可以使用 compareBoundaryPoints()方法来确定这些范围是否有公共<br>的边界（起点或终点）。这个方法接受两个参数：表示比较方式的常量值和要比较的范围。表示比较方<br>式的常量值如下所示<br>Range.START_TO_START(0)：比较第一个范围和第二个范围的起点；<br>Range.START_TO_END(1)：比较第一个范围的起点和第二个范围的终点；<br>Range.END_TO_END(2)：比较第一个范围和第二个范围的终点；<br>Range.END_TO_START(3)：比较第一个范围的终点和第一个范围的起点。<br>compareBoundaryPoints()方法可能的返回值如下：如果第一个范围中的点位于第二个范围中的<br>点之前，返回-1；如果两个点相等，返回 0；如果第一个范围中的点位于第二个范围中的点之后，返回<br>1</p>
<pre><code>var range1 = document.createRange<span class="params">()</span>;
var range2 = document.createRange<span class="params">()</span>;
var p1 = document.getElementById<span class="params">(<span class="string">"p1"</span>)</span>;
range1.selectNodeContents<span class="params">(p1)</span>;
range2.selectNodeContents<span class="params">(p1)</span>;
range2.setEndBefore<span class="params">(p1.lastChild)</span>;
alert<span class="params">(range1.compareBoundaryPoints<span class="params">(Range.START_TO_START, range2)</span>)</span>; <span class="comment">//0</span>
alert<span class="params">(range1.compareBoundaryPoints<span class="params">(Range.END_TO_END, range2)</span>)</span>; <span class="comment">//1</span>
</code></pre><p>在使用完范围之后，最好是调用 detach()方法，以便从创建范围的文档中分离出该范围。调用<br>detach()之后，就可以放心地解除对范围的引用，从而让垃圾回收机制回收其内存了</p>
<pre><code><span class="keyword">range</span>.detach(); <span class="comment">//从文档中分离</span>
<span class="keyword">range</span> = null; <span class="comment">//解除引用</span>
</code></pre></style></p>  
	</div>
		<footer class="article-footer clearfix">




<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2015/09/24/DOM二级和三级-md/" data-title="DOM二级和三级.md | HappyLiuJian" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/09/24/DOM扩展-md/" title="DOM扩展.md">
  <strong>PREVIOUS:</strong><br/>
  <span>
  DOM扩展.md</span>
</a>
</div>


<div class="next">
<a href="/2015/09/24/DOM笔记-md/"  title="DOM笔记.md">
 <strong>NEXT:</strong><br/> 
 <span>DOM笔记.md
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目錄</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DOM2_和_DOM3_级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。为此，DOM2和DOM3级分为许多模块（模块之间具有某种关联),分别描述了DOM的某个非常具体的子集。"><span class="toc-number">1.</span> <span class="toc-text">DOM2 和 DOM3 级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。为此，DOM2和DOM3级分为许多模块（模块之间具有某种关联),分别描述了DOM的某个非常具体的子集。</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#检测是否具有特性"><span class="toc-number">1.1.</span> <span class="toc-text">检测是否具有特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM变化"><span class="toc-number">1.2.</span> <span class="toc-text">DOM变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#针对命名空间问题，Node出现以下的变化"><span class="toc-number">1.2.1.</span> <span class="toc-text">针对命名空间问题，Node出现以下的变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#样式"><span class="toc-number">1.3.</span> <span class="toc-text">样式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#操作样式表"><span class="toc-number">1.3.1.</span> <span class="toc-text">操作样式表</span></a></li></ol></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			<li><a href="/tags/JavaScriptDom5/" title="JavaScriptDom5">JavaScriptDom5<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScriptDom6/" title="JavaScriptDom6">JavaScriptDom6<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScriptDom7/" title="JavaScriptDom7">JavaScriptDom7<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScriptDom8/" title="JavaScriptDom8">JavaScriptDom8<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScriptDom9/" title="JavaScriptDom9">JavaScriptDom9<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScriptDom学习4/" title="JavaScriptDom学习4">JavaScriptDom学习4<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScritpDom简明学习2/" title="JavaScritpDom简明学习2">JavaScritpDom简明学习2<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScritpDom简明学习3/" title="JavaScritpDom简明学习3">JavaScritpDom简明学习3<sup>1</sup></a></li>
		
			<li><a href="/tags/emmetUse/" title="emmetUse">emmetUse<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		<a href="http://weibo.com/http://weibo.com/p/1005053267007984/home?from=page_100505&amp;mod=TAB#place" target="_blank" title="weibo"></a>
		
		
		
		<a href="https://github.com/HappyLiuJian" target="_blank" title="github"></a>
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2015 
		
		<a href="http://yoursite.com" target="_blank" title="Liujian">Liujian</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"happyliujian"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
