
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>JavaScriptDom8 | HappyLiuJian</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Liujian">
    
    <meta name="description" content="函数表达式函数的创建">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="HappyLiuJian" title="HappyLiuJian"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="HappyLiuJian">HappyLiuJian</a></h1>
				<h2 class="blog-motto">HappyLiuJian&#39;s Home</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/13/JavaScriptDom8/" title="JavaScriptDom8" itemprop="url">JavaScriptDom8</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://yoursite.com" title="Liujian">Liujian</a>
    </p>
  <p class="article-time">
    <time datetime="2015-06-13T08:40:39.000Z" itemprop="datePublished">2015-06-13</time>
    更新日期:<time datetime="2015-06-14T12:05:50.388Z" itemprop="dateModified">2015-06-14</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目錄</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#函数表达式"><span class="toc-number">1.</span> <span class="toc-text">函数表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的创建"><span class="toc-number">1.1.</span> <span class="toc-text">函数的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数递归"><span class="toc-number">1.2.</span> <span class="toc-text">函数递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数闭包"><span class="toc-number">1.3.</span> <span class="toc-text">函数闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包与变量"><span class="toc-number">1.3.1.</span> <span class="toc-text">闭包与变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this对象"><span class="toc-number">1.3.2.</span> <span class="toc-text">this对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存泄露"><span class="toc-number">1.3.3.</span> <span class="toc-text">内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模仿块级作用域"><span class="toc-number">1.3.4.</span> <span class="toc-text">模仿块级作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#私有变量"><span class="toc-number">1.3.5.</span> <span class="toc-text">私有变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态私有变量"><span class="toc-number">1.3.6.</span> <span class="toc-text">静态私有变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块模式"><span class="toc-number">1.3.7.</span> <span class="toc-text">模块模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增强的模块模式"><span class="toc-number">1.3.8.</span> <span class="toc-text">增强的模块模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sumary小结"><span class="toc-number">1.4.</span> <span class="toc-text">Sumary小结</span></a></li></ol></li></ol>
		</div>
		
		<h1 id="函数表达式">函数表达式</h1><h2 id="函数的创建">函数的创建</h2><a id="more"></a>
<p>函数声明和函数表达式创建不同</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(arg1,arg2)</span> </span>{            <span class="comment">//函数声明，可以放在调用之后</span>
    <span class="comment">//函数体</span>
}

<span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span><span class="params">(arg1,arg2)</span> </span>{    <span class="comment">//函数表达式创建，只能在调用之前</span>
    <span class="comment">//函数体</span>
}

<span class="keyword">if</span>(condition) {                    <span class="comment">//错误的，函数声明不能这样写</span>
    <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span>{
        <span class="comment">//<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//</span></span><br></pre></td></tr></table></figure></span>

    }
}

<span class="keyword">if</span>(condition) {                    <span class="comment">//正确的，函数表达式可以这样用</span>
    <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="comment">//<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//</span></span><br></pre></td></tr></table></figure></span>

    }
}
</code></pre><h2 id="函数递归">函数递归</h2><p>基本的递归函数如下：</p>
<pre><code>function f1(<span class="built_in">num</span>) {
    <span class="keyword">if</span> (<span class="built_in">num</span> &lt; <span class="number">1</span>) {
        <span class="keyword">return</span> <span class="number">1</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="built_in">num</span>*f1(<span class="built_in">num</span>-<span class="number">1</span>);
    }
}
</code></pre><p>但是基本的递归函数有风险，如下：</p>
<pre><code>function f1(<span class="built_in">num</span>) {
    <span class="keyword">if</span> (<span class="built_in">num</span> &lt; <span class="number">1</span>) {
        <span class="keyword">return</span> <span class="number">1</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="built_in">num</span>*f1(<span class="built_in">num</span>-<span class="number">1</span>);
    }
}

<span class="keyword">var</span> f2 = f1;        <span class="comment">//把f1保存在标量f2中</span>
f1 = <span class="keyword">null</span>;            <span class="comment">//将原来的函数变量设为null</span>
alert(f2(<span class="built_in">num</span>));        <span class="comment">//error;</span>
</code></pre><p>这个时候要使用之前提到的arguments.callee</p>
<pre><code>function f1(<span class="built_in">num</span>) {
    <span class="keyword">if</span> (<span class="built_in">num</span> &lt; <span class="number">1</span>) {
        <span class="keyword">return</span> <span class="number">1</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="built_in">num</span>*arguments.callee(<span class="built_in">num</span>-<span class="number">1</span>);
    }
}

<span class="keyword">var</span> f2 = f1;        <span class="comment">//把f1保存在标量f2中</span>
f1 = <span class="keyword">null</span>;            <span class="comment">//将原来的函数变量设为null</span>
alert(f2(<span class="built_in">num</span>));        <span class="comment">//success;</span>
</code></pre><p>或者使用命名函数表达式：</p>
<pre><code><span class="keyword">var</span> fi = (function f(<span class="built_in">num</span>) {
    <span class="keyword">if</span> (<span class="built_in">num</span> &lt; <span class="number">1</span>) {
        <span class="keyword">return</span> <span class="number">1</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="built_in">num</span>*f1(<span class="built_in">num</span>-<span class="number">1</span>);
    }
});                    <span class="comment">//这种方式在严格模式和不严格模式都有用</span>
</code></pre><h2 id="函数闭包">函数闭包</h2><p>在函数内部定义一个函数，内部函数的作用域链会添加外部函数的活动变量（也就是说内部函数可以调用外部函数的变量），当外部函数销毁时，内部函数依然可以可以使用这些变量；只有内部函数销毁之后才能销毁作用域链</p>
<pre><code><span class="keyword">function</span> createCompare (propertyName) {
    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="keyword">object</span><span class="number">1</span>.<span class="keyword">object</span><span class="number">2</span>) {                <span class="comment">//定义内部闭包函数</span>
        var <span class="keyword">value</span><span class="number">1</span> = <span class="keyword">object</span><span class="number">1</span>[propertyName];
        var <span class="keyword">value</span><span class="number">2</span> = <span class="keyword">object</span><span class="number">2</span>[propertyName];

        <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &lt; <span class="keyword">value</span><span class="number">2</span>) {
            <span class="keyword">return</span> -<span class="number">1</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> <span class="number">0</span>;
        }
    };
}
</code></pre><p>闭包内存占用很高</p>
<h3 id="闭包与变量">闭包与变量</h3><p>闭包只能取得包含函数中任何变量的最后一个值</p>
<pre><code>function a() {
    <span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();

    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) {
        <span class="literal">result</span>[i] = function() {
            <span class="keyword">return</span> i;
        };
    }
    <span class="keyword">return</span> <span class="literal">result</span>;            //最终<span class="literal">result</span>是一个数组，里面每一个项都为<span class="number">10</span>
}

function a() {                //创建匿名函数解决这个问题
    <span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();

    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
        <span class="literal">result</span>[i] = function(num) {
            <span class="keyword">return</span> function() {
                <span class="keyword">return</span> name;
            }
        }
    }(i);

    <span class="keyword">return</span> <span class="literal">result</span>;        //
}
</code></pre><h3 id="this对象">this对象</h3><p>在闭包中使用this对象会导致一些问题</p>
<pre><code><span class="keyword">var</span> name = <span class="string">"The Window"</span>;
    <span class="keyword">var</span> object = {
        name : <span class="string">"My Object"</span>,
        getNameFunc : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">this</span>.name;
        };
    }
};
alert(object.getNameFunc()()); <span class="comment">//"The Window"（在非严格模式下)</span>
</code></pre><p>以上代码先创建了一个全局变量 name，又创建了一个包含 name 属性的对象。这个对象还包含一<br>个方法——getNameFunc()，它返回一个匿名函数，而匿名函数又返回 this.name。由于 getNameFunc()<br>返回一个函数，因此调用 object.getNameFunc()()就会立即调用它返回的函数，结果就是返回一个<br>字符串.</p>
<pre><code><span class="keyword">var</span> name = <span class="string">"The Window"</span>;
<span class="keyword">var</span> object = {
name : <span class="string">"My Object"</span>,
getNameFunc : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> that = <span class="keyword">this</span>;
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">return</span> that.name;
    };
    }
};
alert(object.getNameFunc()()); <span class="comment">//"My Object"</span>
</code></pre><p>在定义匿名函数之前，我们把 this对象赋值给了一个名叫 that的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们<br>在包含函数中特意声名的一个变量。这样就可以访问上一级作用域的变量了</p>
<h3 id="内存泄露">内存泄露</h3><p>（ie9之前JavaScript和com对象使用的垃圾回收机制不同）如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁，产生内存泄露</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>{
    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);
    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        alert(element.id);
    };
}
</code></pre><p>只要匿名函数存在， element 的引用数至少也是 1，因此它所占用的内存就永远不会被回收，这就导致了内存泄露</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>{
    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);
    <span class="keyword">var</span> id = element.id;                <span class="comment">//创建一个element.id的副本</span>
    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        alert(id);                        <span class="comment">//匿名函数只调用副本</span>
    };
    element = <span class="literal">null</span>;                        <span class="comment">//释放html的空间</span>
}
</code></pre><p>正常回收了element占用的内存</p>
<h3 id="模仿块级作用域">模仿块级作用域</h3><p>JavaScript 没有块级作用域的概念。这意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span><span class="params">(count)</span><span class="comment">{
    for (var i=0; i &lt; count; i++){
        alert(i);
    }</span>
    <span class="title">alert</span><span class="params">(i)</span>;</span> <span class="comment">//计数，这里的alert(i)是可以生效的，因为没有块级作用域;</span>
}
</code></pre><p>任何时候要定义一个块级作用域，把私有的变量放在其中都可以使用如下的代码</p>
<pre><code><span class="list">(<span class="keyword">function</span><span class="list">()</span><span class="collection">{
    //这里是块级作用域
}</span>)</span><span class="list">()</span><span class="comment">;</span>
</code></pre><p>这条语句的原理是由于把(function(){})视为了一个变量名，变量名代表一个函数，这个函数内部的空间是一个块级作用域</p>
<h3 id="私有变量">私有变量</h3><p>严格来讲， JavaScript 中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。</p>
<p>如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，就可以创建用于访问私有变量的公有方法。我们把有权访问私有变量和私有函数的公有方法称为特权方法（privileged method）。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span><span class="params">()</span></span>{            <span class="comment">//在构造函数中定义特权方法</span>
    <span class="comment">//私有变量和私有函数</span>
    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="comment">//特权方法</span>
    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>{        <span class="comment">//利用this所以可以调用外部函数的变量</span>
        privateVariable++;
        <span class="keyword">return</span> privateFunction();
    };
}
</code></pre><p>在构造函数中定义特权方法也有一个缺点，那就是你必须使用构造函数模式来达到这个目的。第 6章曾经讨论过，构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题</p>
<h3 id="静态私有变量">静态私有变量</h3><p>在私有作用域里定义私有变量和函数</p>
<pre><code>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="comment">//私有变量和私有函数</span>
    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="comment">//构造函数</span>
    MyObject = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    };
    <span class="comment">//公有/特权方法</span>
    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        privateVariable++;
        <span class="keyword">return</span> privateFunction();
    };
})();
</code></pre><p>需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明 MyObject 时使用 var 关键字、</p>
<p>以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量，这一个缺点和原型模式构造函数相同</p>
<h3 id="模块模式">模块模式</h3><p>前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式（modulepattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。按照惯例，JavaScript是以对象字面量的方式来创建单例对象的</p>
<pre><code><span class="keyword">var</span> singleton = {            <span class="comment">//这里就是创建一个单例</span>
    name : value,
    method : <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="comment">//这里是方法的代码</span>
    }
};

<span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="comment">//私有变量和私有函数</span>
    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="comment">//特权/公有方法和属性</span>
    <span class="keyword">return</span> {
        publicProperty: <span class="literal">true</span>,
        publicMethod : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        privateVariable++;
        <span class="keyword">return</span> privateFunction();
    }
    };
}();
</code></pre><p>简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是 Object 的实例，因为最终要通过一个对象字面量来表示它</p>
<h3 id="增强的模块模式">增强的模块模式</h3><p>增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况</p>
<pre><code><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="comment">//私有变量和私有函数</span>
    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="comment">//创建对象</span>
    <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();
    <span class="comment">//添加特权/公有属性和方法</span>
    object.publicProperty = <span class="literal">true</span>;
    object.publicMethod = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        privateVariable++;
        <span class="keyword">return</span> privateFunction();
    };
    <span class="comment">//返回这个对象</span>
    <span class="keyword">return</span> object;
}();
</code></pre><h2 id="Sumary小结">Sumary小结</h2><p>在 JavaScript 编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，<br>从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用 JavaScript 函数的强大方式。以下总结<br>了函数表达式的特点。<br> 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表<br>达式也叫做匿名函数。<br> 在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；<br> 递归函数应该始终使用 arguments.callee 来递归地调用自身，不要使用函数名——函数名可<br>能会发生变化。<br>当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理<br>如下。<br> 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。<br> 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。<br> 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。<br>使用闭包可以在 JavaScript 中模仿块级作用域（JavaScript 本身没有块级作用域的概念），要点如下。<br> 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。<br> 结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外<br>部作用域）中的变量。<br>闭包还可以用于在对象中创建私有变量，相关概念和要点如下。<br> 即使 JavaScript 中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公<br>有方法可以访问在包含作用域中定义的变量。<br> 有权访问私有变量的公有方法叫做特权方法。<br> 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强<br>的模块模式来实现单例的特权方法。<br>JavaScript 中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为<br>创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScriptDom8/">JavaScriptDom8</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2015/06/13/JavaScriptDom8/" data-title="JavaScriptDom8 | HappyLiuJian" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/06/14/JavaScriptDom9/" title="JavaScriptDom9">
  <strong>PREVIOUS:</strong><br/>
  <span>
  JavaScriptDom9</span>
</a>
</div>


<div class="next">
<a href="/2015/06/13/JavaScriptDom7/"  title="JavaScriptDom7">
 <strong>NEXT:</strong><br/> 
 <span>JavaScriptDom7
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目錄</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#函数表达式"><span class="toc-number">1.</span> <span class="toc-text">函数表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的创建"><span class="toc-number">1.1.</span> <span class="toc-text">函数的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数递归"><span class="toc-number">1.2.</span> <span class="toc-text">函数递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数闭包"><span class="toc-number">1.3.</span> <span class="toc-text">函数闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包与变量"><span class="toc-number">1.3.1.</span> <span class="toc-text">闭包与变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this对象"><span class="toc-number">1.3.2.</span> <span class="toc-text">this对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存泄露"><span class="toc-number">1.3.3.</span> <span class="toc-text">内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模仿块级作用域"><span class="toc-number">1.3.4.</span> <span class="toc-text">模仿块级作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#私有变量"><span class="toc-number">1.3.5.</span> <span class="toc-text">私有变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态私有变量"><span class="toc-number">1.3.6.</span> <span class="toc-text">静态私有变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块模式"><span class="toc-number">1.3.7.</span> <span class="toc-text">模块模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增强的模块模式"><span class="toc-number">1.3.8.</span> <span class="toc-text">增强的模块模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sumary小结"><span class="toc-number">1.4.</span> <span class="toc-text">Sumary小结</span></a></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			<li><a href="/tags/JavaScriptDom5/" title="JavaScriptDom5">JavaScriptDom5<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScriptDom6/" title="JavaScriptDom6">JavaScriptDom6<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScriptDom7/" title="JavaScriptDom7">JavaScriptDom7<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScriptDom8/" title="JavaScriptDom8">JavaScriptDom8<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScriptDom9/" title="JavaScriptDom9">JavaScriptDom9<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScriptDom学习4/" title="JavaScriptDom学习4">JavaScriptDom学习4<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScritpDom简明学习2/" title="JavaScritpDom简明学习2">JavaScritpDom简明学习2<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScritpDom简明学习3/" title="JavaScritpDom简明学习3">JavaScritpDom简明学习3<sup>1</sup></a></li>
		
			<li><a href="/tags/emmetUse/" title="emmetUse">emmetUse<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		<a href="http://weibo.com/http://weibo.com/p/1005053267007984/home?from=page_100505&amp;mod=TAB#place" target="_blank" title="weibo"></a>
		
		
		
		<a href="https://github.com/https://github.com/HappyLiuJian" target="_blank" title="github"></a>
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2015 
		
		<a href="http://yoursite.com" target="_blank" title="Liujian">Liujian</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"happyliujian"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
